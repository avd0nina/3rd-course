## Синхронизация доступа к разделяемому ресурсу

1. Измените реализацию очереди, добавив спинлок для синхронизации доступа к разделяемым данным.

   i. Подумайте, какие операции должны выполняться с захваченным
примитивом синхронизации, а какие не обязательно. Объясните
принятое решение. Что такое критическая секция?

2. Убедитесь, что не возникает ошибок передачи данных через очередь.
3. Поиграйте параметрами из пункта 2.1:
	1. Оцените загрузку процессора.
	2. Оцените время проведенное в пользовательском режиме и в режиме ядра.
	3. Оцените текущую заполненность очереди, количество попыток чтения-записи и количество прочитанных-записанных данных.
	4. Объясните наблюдаемые результаты.
4. Часто бывает, что поток пишущий данные в очередь вынужден ожидать их (например, из сети на `select()`/`poll()`). Проэмулируйте эту ситуацию, добавив в поточную функцию писателя периодический вызов `usleep(1)`. Выполните задания из пункта 3.
5. Измените реализацию очереди, заменив спинлок на мутекс. Проделайте задания из пунктов 2, 3 и 4. Сравните со спинлоком.

   i. Загружает ли реализация на мутексах процессор почти на уровне
спинлока?
Если да, то попробуйте исправить, вставив в нужном месте `usleep`.
Поэкспериментируйте со значением `usleep`, чтобы производительность
очереди была на уровне остальных вариантов.

6. Измените реализацию очереди, добавив условную переменную. Проделайте задания из пунктов 2, 3 и 4. Сравните со спинлоком и мутексом.
7. Используйте для синхронизации доступа к очереди семафоры. Проделайте задания из пунктов 2, 3 и 4. Сравните со спинлоком, мутексом и условной переменной.

	i. Мутекс и бинарный семафор.
Зачем одно, если есть другое?
Если нашли ответ, не поленитесь его проверить - так ли это?
Если получилось не так, то что надо исправить в коде?

