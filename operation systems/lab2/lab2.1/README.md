## Проблема конкурентного доступа к разделяемому ресурсу
	
1. В каталоге `sync` репозитория `git@github.com:mrutman/os.git` вы найдете простую реализацию очереди на списке. Изучите код, соберите и запустите программу `queue-example.c`. Посмотрите вывод программы и убедитесь что он соответствует вашему пониманию работы данной реализации очереди. Добавьте реализацию функции `queue_destroy()`.
2. Изучите код программы `queue-threads.c` и разберитесь что она делает. Соберите программу.
	1. Запустите программу несколько раз. Если появляются ошибки выполнения, попытайтесь их объяснить и определить что именно вызывает ошибку. Какие именно ошибки вы наблюдали?
	2. Поиграйте следующими параметрами:
		1. размером очереди (задается в `queue_init()`). Запустите программу с размером очереди от 1000 до 1000000.
		2. привязкой к процессору (задается функцией `set_cpu()`). Привяжите потоки к одному процессору (ядру) и к разным.
		3. планированием потоков (функция `sched_yield()`). Попробуйте убрать эту функцию перед созданием второго потока.
		4. Объясните наблюдаемые результаты.
  	3. Для пункта “заполняемость очереди” - экспериментально обоснуйте
обьяснение наблюдаемого результата. Для этого может пригодиться
отладочный вывод каких-то событий в очереди или какой-то информации
о ее состоянии, например, когда она становится пустой или заполненной.
Не переборщите с отладочным выводом - вывод штука долгая и влияет
на работу самой очереди, замедляя ее.
