Реализуйте односвязный список, хранящий строки длиной менее 100 символов, у которого с каждым элементом связан отдельный примитив синхронизации (за основу можно взять реализацию списка, на котором построен очередь `queue_t`). Объявление такого списка может выглядеть, например, так:
```C
typedef struct _Node {
	char value[100];
	struct _Node* next;
	pthread_mutex_t sync;
} Node;

typedef struct _Storage {
	Node *first;
} Storage;
```
Первый поток пробегает по всему хранилищу и ищет количество пар строк, идущих по возрастанию длины. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится, количество выполненных им итераций и сразу начинает новый поиск.
Второй поток пробегает по всему хранилищу и ищет количество пар строк, идущих по убыванию длины. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится количество выполненных им итераций и сразу начинает новый поиск.
Третий поток пробегает по всему хранилищу и ищет количество пар строк, имеющих одинаковую длину. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится количество выполненных им итераций и сразу начинает новый поиск.
Запускает 3 потока, которые в непрерывном бесконечном цикле случайным образом проверяют - требуется ли переставлять соседние элементы списка (не значения) и выполняют перестановку. Каждая успешная попытка перестановки фиксируется в соответствующей глобальной переменной-счетчике.
Используйте для синхронизации доступа к элементам списка спинлоки, мутексы и блокировки чтения-записи. Понаблюдайте как изменяются (и изменяются ли) значения переменных счетчиков и объясните результат. Проверьте для списков длины 100, 1000, 10000, 100000.

При реализации обратите внимание на следующие пункты:
* продумайте ваше решение, чтобы избежать ошибок соревнования;
* необходимо блокировать все записи с данными которых производится работа;
* при перестановке записей списка, необходимо блокировать три записи;
* чтобы избежать мертвых блокировок, примитивы записей, более близких к началу списка, всегда захватывайте раньше.
